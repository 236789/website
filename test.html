function loadMessages() {
    /**
     * =========================================================================
     * STAGE 1: LISTENER INITIALIZATION & CLEANUP
     * =========================================================================
     * We must ensure that we aren't creating a 'memory leak' by having multiple
     * active connections to the Firestore database. Every time this function
     * is invoked (e.g., on page load or auth change), we kill the old stream.
     */
    if (unsubscribe) {
        console.log("Terminating existing message stream...");
        unsubscribe();
    }

    /**
     * =========================================================================
     * STAGE 2: DATABASE QUERY CONFIGURATION
     * =========================================================================
     * We target the 'wall_messages' collection. 
     * We sort by 'createdAt' (Server Timestamp) in descending order.
     * We limit the initial load to 50 items to optimize mobile performance.
     */
    const messageQuery = query(
        collection(db, "wall_messages"), 
        orderBy("createdAt", "desc"), 
        limit(50)
    );

    /**
     * =========================================================================
     * STAGE 3: REAL-TIME DATA PROCESSING
     * =========================================================================
     * This listener triggers automatically whenever a new message is added,
     * edited, or deleted in the backend.
     */
    unsubscribe = onSnapshot(messageQuery, snapshot => {
        const feed = messagesFeed;
        
        // AUTO-SCROLL DETECTION:
        // We check if the user is near the bottom (within 200px) so we can 
        // decide whether to snap the view to new messages automatically.
        const wasAtBottom = (feed.scrollHeight - feed.scrollTop <= feed.clientHeight + 200);

        // DOCUMENT TRANSFORMATION:
        // Snapshots come in 'newest first' format. We need an array for looping.
        const docs = [];
        snapshot.forEach(doc => {
            docs.push({ 
                id: doc.id, 
                ...doc.data() 
            });
        });

        // DISPLAY ORDERING:
        // We reverse the array to ensure chronological order (Old at Top, New at Bottom).
        docs.reverse();

        // DOM RESET:
        // Clear the feed container to prepare for a fresh render cycle.
        feed.innerHTML = '';

        /**
         * =====================================================================
         * STAGE 4: THE RENDERING ENGINE LOOP
         * =====================================================================
         * We iterate through every individual message document retrieved.
         */
        docs.forEach(data => {
            
            // SECURITY CHECK: Skip rendering if the message is soft-deleted.
            if (data.isDeleted) return;

            // IDENTITY MAPPING:
            const msgId = data.id;
            const isMine = (data.uid === currentUid);
            const isBot = (data.isBot === true);
            
            // ROLE DETERMINATION:
            // We use the flags stored on the message document at the time of sending.
            const userIsAdmin = (data.isAdmin === true);
            const userIsOwner = (data.isOwner === true);
            const userIsMod = (data.isMod === true);
            const userIsHelper = (data.isHelper === true);

            // COMPONENT INITIALIZATION:
            const wrapper = document.createElement('div');
            wrapper.className = `msg-wrapper ${isMine ? 'mine' : 'theirs'}`;
            wrapper.dataset.id = msgId;

            // TIMESTAMP GENERATION:
            let time = "";
            if (data.createdAt && data.createdAt.toDate) {
                time = data.createdAt.toDate().toLocaleTimeString([], {
                    hour: '2-digit', 
                    minute: '2-digit'
                });
            }

            // STYLE CONFIGURATION:
            let bubbleClass = 'msg-bubble';
            let bubbleContent = "";

            // Check if the user has an equipped Text Cosmetic (Matrix, Gold, etc.)
            const textStyleClass = (data.equippedText && data.equippedText.cssClass) ? data.equippedText.cssClass : "";

            // -----------------------------------------------------------------
            // LOGIC BLOCK: BUBBLE COLOR & BANNER ASSIGNMENT
            // -----------------------------------------------------------------
            // We apply the SnapVibe Glass style by default, but if a banner 
            // is equipped, we stack the banner's background logic on top.
            if (data.equippedBanner && data.equippedBanner.cssClass) {
                bubbleClass += ` ${data.equippedBanner.cssClass}`;
            } else {
                // Fallback role-based styling if no banner is equipped.
                if (isBot) bubbleClass += ' bot-msg';
                else if (userIsOwner) bubbleClass += ' owner-msg';
                else if (userIsAdmin) bubbleClass += ' admin-msg';
                else if (userIsMod) bubbleClass += ' mod-msg';
                else if (userIsHelper) bubbleClass += ' helper-msg';
            }

            // -----------------------------------------------------------------
            // LOGIC BLOCK: CONTENT TYPE HANDLER
            // -----------------------------------------------------------------

            /**
             * CATEGORY 1: SYSTEM ALERTS
             * Used for Jackpots or important automated server messages.
             */
            if (data.uid === 'system-alert') {
                bubbleClass += ' jackpot-system-alert'; 
                bubbleContent = data.text; 
            }
            
            /**
             * CATEGORY 2: VOCAL MESSAGES (VOICE NOTES)
             * Fix: We use preload="metadata" and ensure the audio player
             * is properly constructed within the glass bubble.
             */
            else if (data.type === 'vocal') {
                bubbleContent = `
                    <div class="audio-msg-container">
                        <span style="font-size:10px; font-weight:900; opacity:0.8; font-family:'Orbitron'; color:var(--p);">
                            <i class="fas fa-microphone"></i> MESAJ VOCAL
                        </span>
                        <audio controls preload="metadata" class="audio-player">
                            <source src="${data.audioUrl}" type="audio/webm">
                            <source src="${data.audioUrl}" type="audio/mp4">
                            <source src="${data.audioUrl}" type="audio/mpeg">
                            Browserul tƒÉu nu suportƒÉ redarea audio.
                        </audio>
                    </div>`;
            }

            /**
             * CATEGORY 3: INTERACTIVE POLLS
             */
            else if (data.type === 'poll') {
                const now = Date.now();
                const isExpired = (now > data.expiresAt);
                const myVote = data.votes ? data.votes[currentUid] : undefined;
                const hasVoted = (myVote !== undefined);
                const options = data.options || [];
                
                const results = new Array(options.length).fill(0);
                let totalVotes = 0;
                
                if (data.votes) {
                    Object.values(data.votes).forEach(val => {
                        results[val]++; 
                        totalVotes++; 
                    });
                }

                let optionsHtml = '<div class="poll-options" style="margin-top:10px; display:flex; flex-direction:column; gap:8px;">';
                options.forEach((opt, idx) => {
                    if (isExpired || hasVoted) {
                        const count = results[idx];
                        const percent = totalVotes > 0 ? Math.round((count / totalVotes) * 100) : 0;
                        const myChoiceStyle = (myVote === idx) ? "border: 1px solid var(--primary); box-shadow: 0 0 10px var(--primary-dim);" : "";
                        
                        optionsHtml += `
                            <div class="poll-btn" style="cursor:default; position:relative; overflow:hidden; border-radius:8px; padding:10px; background:rgba(255,255,255,0.05); ${myChoiceStyle}">
                                <div class="poll-result-bar" style="position:absolute; top:0; left:0; bottom:0; background:rgba(41,243,255,0.2); width:${percent}%; transition: width 1s ease;"></div>
                                <div class="poll-text" style="position:relative; z-index:1; display:flex; justify-content:space-between; font-size:12px;">
                                    <span>${opt} ${myVote === idx ? '<b>(Tu)</b>' : ''}</span>
                                    <span class="poll-percent" style="font-weight:900;">${percent}%</span>
                                </div>
                            </div>`;
                    } else {
                        optionsHtml += `
                            <button class="poll-btn" 
                                    style="padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.05); color:#fff; cursor:pointer;" 
                                    onclick="votePoll('${msgId}', ${idx})">${opt}</button>`;
                    }
                });
                optionsHtml += '</div>';

                let durationTxt = data.durationLabel || "N/A";
                let statusText = isExpired ? "Vot √éncheiat" : `VoteazƒÉ (${durationTxt})`;
                let viewResultsLink = (isExpired || hasVoted) ? ` ‚Ä¢ <span style="cursor:pointer; color:var(--primary); font-weight:700; text-decoration:underline;" onclick="openPollVoters('${msgId}')">Vezi Votan»õii</span>` : "";
                
                bubbleContent = `
                    <div class="poll-card" style="min-width:240px; padding:5px;">
                        <div class="poll-question" style="font-family:'Orbitron'; font-size:13px; font-weight:700; color:var(--p);">${data.question}</div>
                        ${optionsHtml}
                        <div class="poll-meta" style="font-size:10px; margin-top:10px; opacity:0.6; text-align:right;">${totalVotes} Voturi ‚Ä¢ ${statusText}${viewResultsLink}</div>
                    </div>`;
            } 

            /**
             * CATEGORY 4: STANDARD MESSAGES (TEXT & MEDIA)
             */
            else {
                // REPLY LOGIC:
                if (data.replyToName) {
                    const rawReply = (data.replyToText || "Media/Audio");
                    const safeReply = rawReply.replace(/</g, "&lt;");
                    const truncatedReply = safeReply.length > 50 ? safeReply.substring(0, 50) + "..." : safeReply;
                    
                    bubbleContent += `
                        <span class="quoted-msg" style="display:block; background:rgba(0,0,0,0.2); border-left:3px solid var(--p); padding:6px 10px; border-radius:6px; font-size:11px; margin-bottom:8px; opacity:0.8;">
                            <strong style="color:var(--p); display:block; font-size:10px; margin-bottom:2px;">@${data.replyToName}</strong>
                            ${truncatedReply}
                        </span>`;
                }

                // IMAGE LOGIC:
                if (data.image) {
                    bubbleContent += `
                        <div class="message-image-wrap" style="margin-bottom:8px; border-radius:12px; overflow:hidden;">
                            <img src="${data.image}" 
                                 class="msg-img-content" 
                                 style="display:block; max-width:100%; border-radius:12px; cursor:pointer;"
                                 onclick="window.open('${data.image}', '_blank')">
                        </div>`;
                }
                
                // TEXT BODY LOGIC:
                if (data.isSpecial === true) {
                    // System bot formatting bypass.
                    bubbleContent += (data.text || "").replace(/\n/g, "<br>");
                } 
                else {
                    // Regular user text with security sanitization.
                    let baseText = (data.text || "").replace(/</g, "&lt;").replace(/\n/g, "<br>");
                    
                    if (baseText) {
                        // linkify() handles both URLs and Mention Tags.
                        let processedBody = textStyleClass 
                            ? `<span class="${textStyleClass}">${linkify(baseText)}</span>` 
                            : linkify(baseText);

                        bubbleContent += `<div>${processedBody}</div>`;
                    }
                }
            }

            // -----------------------------------------------------------------
            // SUB-SECTION: IDENTITY COMPONENT ASSEMBLY
            // -----------------------------------------------------------------
            
            // Name Rendering with Bots handling:
            let finalDisplayName = (data.name || "Anonim");
            if (isBot) finalDisplayName = `ü§ñ ${finalDisplayName}`;
            
            // If the user has equipped a Text Color cosmetic:
            if (textStyleClass) {
                finalDisplayName = `<span class="${textStyleClass}">${(data.name || "Anonim")}</span>`;
            }

            // Staff Badge construction:
            let staffBadgeHtml = "";
            if (userIsOwner) {
                staffBadgeHtml = ` <span class="owner-badge"><i class="fas fa-crown"></i> OWNER</span>`;
            } else if (userIsAdmin) {
                staffBadgeHtml = ` <span class="admin-badge"><i class="fas fa-shield-alt"></i> ADMIN</span>`;
            } else if (userIsMod) {
                staffBadgeHtml = ` <span class="mod-badge"><i class="fas fa-gavel"></i> MOD</span>`;
            } else if (userIsHelper) {
                staffBadgeHtml = ` <span class="helper-badge"><i class="fas fa-hands-helping"></i> HELPER</span>`;
            }

            // Standard cosmetic badge (Purchased from Shop):
            let cosmeticBadgeHtml = getCosmeticBadge(data.equippedBadge);
            
            // Concatenate the final author header:
            let fullAuthorHeader = finalDisplayName + staffBadgeHtml + cosmeticBadgeHtml;

            // -----------------------------------------------------------------
            // SUB-SECTION: INTERACTION LAYERS (REACTIONS / MENU / SEEN)
            // -----------------------------------------------------------------

            // Reaction Pill Generation:
            let reactionsContainerHtml = "";
            if (data.reactions && Object.keys(data.reactions).length > 0) {
                reactionsContainerHtml = `<div class="msg-reactions" style="display:flex; flex-wrap:wrap; gap:4px; margin-top:6px;">`;
                const reactionMap = {};
                
                Object.values(data.reactions).forEach(emoji => { 
                    reactionMap[emoji] = (reactionMap[emoji] || 0) + 1; 
                });
                
                for (let [emoji, count] of Object.entries(reactionMap)) { 
                    reactionsContainerHtml += `
                        <span class="reaction-badge" 
                              style="cursor:pointer; background:rgba(0,0,0,0.3); padding:3px 8px; border-radius:20px; font-size:11px; border:1px solid rgba(255,255,255,0.1);"
                              onclick="window.openReactionList('${msgId}', '${emoji}')">
                            ${emoji} <span style="font-weight:800; margin-left:2px;">${count}</span>
                        </span>`; 
                }
                reactionsContainerHtml += `</div>`;
            }

            // Seen Indicator logic:
            const totalSeen = (data.seenBy || []).length;
            const seenIndicatorHtml = `
                <button class="seen-btn ${totalSeen > 0 ? 'active' : ''}" 
                        style="background:none; border:none; color:var(--dim); font-size:10px; cursor:pointer;"
                        onclick="window.openSeenByList('${msgId}')">
                    <i class="fas fa-eye"></i> ${totalSeen}
                </button>`;

            // Dropdown Menu Construction:
            let dropdownMenuHtml = "";
            const isSystemOrBot = (data.uid === 'system-alert' || data.isBot === true);
            const canManage = (isMine || isAdmin || isOwner || isMod);

            if (!isSystemOrBot || isAdmin || isOwner) {
                let pinningOption = "";
                if (isAdmin || isOwner || isMod || isHelper) {
                    if (data.isPinned) {
                        pinningOption = `<button onclick="window.unpinMsg('${msgId}')" style="color:#ff4757;"><i class="fas fa-thumbtack"></i> DezfixeazƒÉ</button>`;
                    } else {
                        pinningOption = `<button onclick="window.pinMsg('${msgId}')"><i class="fas fa-thumbtack"></i> FixeazƒÉ</button>`;
                    }
                }

                dropdownMenuHtml = `
                    <div class="msg-options" onclick="toggleMenu('${msgId}')" style="cursor:pointer; opacity:0.6; padding:5px;">
                        <i class="fas fa-ellipsis-v"></i>
                    </div>
                    <div id="menu-${msgId}" class="options-dropdown">
                        ${!isSystemOrBot ? `
                            <button onclick="startReply('${msgId}', '${(data.name || "User")}', '${(data.text || "Media").replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${data.uid}')">
                                <i class="fas fa-reply"></i> RƒÉspunde
                            </button>
                            <button onclick="toggleEmojiPicker('${msgId}')">
                                <i class="far fa-heart"></i> Reac»õioneazƒÉ
                            </button>
                            <button onclick="window.openUserProfile('${data.uid}')">
                                <i class="fas fa-user"></i> Profil
                            </button>` : ''}

                        ${pinningOption}

                        ${canManage ? `
                            <button class="delete-btn" onclick="deleteMsg('${msgId}')">
                                <i class="fas fa-trash"></i> »òterge
                            </button>` : ''}
                        
                        ${(isAdmin || isOwner || isMod || isHelper) && !isSystemOrBot ? `
                            <button class="mute-btn" onclick="handleMuteAction('${data.uid}', '${data.name}')">
                                <i class="fas fa-microphone-slash"></i> Mute / Unmute
                            </button>` : ''}
                        
                        ${isOwner && !isSystemOrBot ? `
                            <button style="color:#ff4757; font-weight:900;" onclick="banIpUser('${data.uid}', '${data.name}', '${data.ip}')">
                                <i class="fas fa-gavel"></i> BAN IP
                            </button>` : ''}
                        
                        <div id="emojis-${msgId}" class="emoji-picker-menu">
     <div class="emoji-btn" onclick="reactMsg('${msgId}', '‚ù§Ô∏è')">‚ù§Ô∏è</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üòÇ')">üòÇ</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üî•')">üî•</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üëç')">üëç</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üò°')">üò°</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü§¨')">ü§¨</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üôÇ')">üôÇ</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üòí')">üòí</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü•±')">ü•±</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üòò')">üòò</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üí©')">üí©</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üò≠')">üò≠</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üó£Ô∏è')">üó£Ô∏è</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üëå')">üëå</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü§£')">ü§£</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üòé')">üòé</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü§©')">ü§©</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üòç')">üòç</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üòë')">üòë</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üôÑ')">üôÑ</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üò±')">üò±</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü§™')">ü§™</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü•∫')">ü•∫</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü§°')">ü§°</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'ü§ë')">ü§ë</div>
                            <div class="emoji-btn" onclick="reactMsg('${msgId}', 'üòü')">üòü</div>
                        </div>
                    </div>
                `;
            }

            // =================================================================
            // STAGE 5: FINAL ASSEMBLY & DOM INJECTION
            // =================================================================
            // We combine all the logical units into a single HTML structure.
            // Note: tagUser logic is triggered by clicking the bubble.
            
            const cleanNameForTag = (data.name || "User").replace(/'/g, "\\'");
            
            wrapper.innerHTML = `
                <div class="msg-author" style="font-size:11px; margin-bottom:4px; font-weight:700;">
                    ${fullAuthorHeader}
                </div>
                <div class="${bubbleClass}" 
                     style="cursor:pointer;"
                     onclick="window.tagUser('${cleanNameForTag}')">
                    ${bubbleContent}
                </div>
                ${reactionsContainerHtml}
                <div class="msg-info" style="display:flex; gap:10px; margin-top:4px; align-items:center; opacity:0.7; font-size:9px;">
                    <span class="msg-time">${time}</span> 
                    ${seenIndicatorHtml}
                </div>
                ${dropdownMenuHtml}
            `;
            
            // Append the finished message row to the live feed.
            feed.appendChild(wrapper);
            
            // Register the message for the IntersectionObserver to track 'SeenBy' status.
            if (typeof seenObserver !== 'undefined' && seenObserver.observe) {
                seenObserver.observe(wrapper);
            }
        });
        
        /**
         * =====================================================================
         * STAGE 6: VIEWPORT SYNCHRONIZATION
         * =====================================================================
         * If the user was already looking at the bottom, or if they were the 
         * one who sent the message, we force the scroll to jump to the new content.
         */
        const lastMsgObj = docs[docs.length - 1];
        const sentByMe = (lastMsgObj && lastMsgObj.uid === currentUid);
        
        if (wasAtBottom || sentByMe) {
            feed.scrollTo({ 
                top: feed.scrollHeight, 
                behavior: 'smooth' 
            });
        }
    });

    /**
     * =========================================================================
     * STAGE 7: DEBUGGING & AUDIT
     * =========================================================================
     * Final line count and operational log.
     */
    console.log("Message listener successfully initialized with full feature set.");
    // END OF FUNCTION loadMessages
}
